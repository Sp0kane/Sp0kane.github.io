<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WAAAGH! Space Shoota!</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
            width: 100%;
            height: 100%;
        }
        body {
            font-family: Arial, sans-serif;
            background-color: #222;
            color: #0f0;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        #startScreen, #upgradeMenu, #gameOverMenu {
            display: none;
        }
        #startScreen, #upgradeMenu, #gameOverMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }
        #startScreen button, #upgradeMenu button, #gameOverMenu button {
            background-color: #444;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 15px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Arial', sans-serif;
            font-size: 1.2em;
        }
        #startScreen button:hover, #upgradeMenu button:hover, #gameOverMenu button:hover {
            background-color: #666;
        }
        #upgradeMenu {
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            background-color: green;
            padding: 10px;
            border: 2px solid #0f0;
            color: #fff;
        }
        #instructions {
            font-size: 16px;
            color: #fff;
            text-align: left;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="startScreen">
        <h1>WAAAGH! Space Shoota!</h1>
        <div id="instructions">
            <p><strong>Instructions:</strong></p>
            <ul>
                <li>Move wit <strong>WASD</strong> or <strong>Arrow Keys</strong></li>
                <li>Hold <strong>Shift</strong> ta go fasta (uses Guzzle)</li>
                <li>Left click ta shoot</li>
                <li>Right click ta drop a bomb (costs ammo)</li>
                <li>Grab scrap from dead enemies ta upgrade yer ship</li>
            </ul>
        </div>
        <button onclick="startGame()">LET'S WAAAGH!</button>
    </div>
    <div id="upgradeMenu">
        <h2>UPGRADE YER SHIP, YA GIT!</h2>
        <div id="currentScrap">Scrap: 0</div>
        <button onclick="upgradeShootas()">More Dakka (10 scrap)</button>
        <button onclick="upgradeArma()">Betta Arma (15 scrap)</button>
        <button onclick="upgradeSpeed()">Go Fasta (5 scrap)</button>
        <button onclick="startNextWave()">BACK TO FOIGHTIN'</button>
    </div>
    <div id="gameOverMenu">
        <h2>GAME OVER, YA GIT!</h2>
        <button onclick="restartGame()">TRY AGAIN</button>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Initial call to set the canvas size

        // Load enemy images
        const images = {
            humie: new Image(),
            pointyEar: new Image(),
            tinEad: new Image(),
            spaceNasty: new Image(),
            humieProjectile: new Image(),
            pointyEarProjectile: new Image(),
            tinEadProjectile: new Image(),
            spaceNastyProjectile: new Image(),
            orkProjectile: new Image(),
            shipExplosion: new Image(),
            projectileExplosion: new Image(),
            orkShip: new Image(),
            waaaghShip: new Image(),
            bomb: new Image(),
            explodedBomb: new Image()
        };
        images.humie.src = 'https://i.imgur.com/qGd6kKm.png';
        images.pointyEar.src = 'https://i.imgur.com/2385clh.png';
        images.tinEad.src = 'https://i.imgur.com/3DrKiMa.png';
        images.spaceNasty.src = 'https://i.imgur.com/44s62sE.png';
        images.humieProjectile.src = 'https://i.imgur.com/s003Ghn.png';
        images.pointyEarProjectile.src = 'https://i.imgur.com/QBYlWW1.png';
        images.tinEadProjectile.src = 'https://i.imgur.com/eNps7X0.png';
        images.spaceNastyProjectile.src = 'https://i.imgur.com/phmf1c6.png';
        images.orkProjectile.src = 'https://i.imgur.com/rZjIZtB.png';
        images.shipExplosion.src = 'https://i.imgur.com/xJzytnV.png'; // Ship explosion sprite sheet
        images.projectileExplosion.src = 'https://i.imgur.com/fP4DBiR.png'; // Projectile explosion sprite sheet
        images.orkShip.src = 'https://i.imgur.com/uUcrlVb.png'; // Load orkShip image
        images.waaaghShip.src = 'https://i.imgur.com/Rlt3p1z.png'; // Load waaaghShip image
        images.bomb.src = 'https://i.imgur.com/FxStkCk.png'; // Bomb image
        images.explodedBomb.src = 'https://i.imgur.com/MhDUnb5.png'; // Bomb explosion sprite

        // Load sounds
        const fireSound = new Audio('https://cdn.freesound.org/previews/239/239596_109726-lq.mp3');
        fireSound.loop = true;  // Ensure the sound can loop
        const waaaghSound = new Audio('https://cdn.freesound.org/previews/371/371211_6907558-lq.mp3'); // Waaagh activation sound
        const bombSound = new Audio('https://cdn.freesound.org/previews/741/741175_71257-lq.mp3'); // Bomb explosion sound

        // Ork Ship
        const orkShip = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            width: 60,  // Doubled the width
            height: 80, // Doubled the height
            image: images.orkShip,
            color: 'green',
            speed: 5,
            shootas: 1,
            arma: 0,
            scrap: 0,
            health: 100,
            ammo: 100,
            angle: Math.PI, // Rotated 180 degrees
            waaaghActive: false,
            waaaghSpeedBoost: 2,
            originalSpeed: 5,
            waaaghAmmoBoost: false,
            waaaghAmmoGranted: false, // Add flag for ammo grant
            guzzle: 100, // Add Guzzle meter
            isBoosting: false // Add boosting state
        };

        // Detect if the user is on a mobile device
        function isMobile() {
            return /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop|BlackBerry/i.test(navigator.userAgent);
        }

        const isMobileDevice = isMobile();

        // Adjust speeds for mobile devices
        const speedMultiplier = isMobileDevice ? 0.5 : 1;

        // Game state
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let particles = [];
        let explosions = [];
        let bombs = [];
        let score = 0;
        let level = 1;
        let wave = 1;
        let waaghMeter = 0;
        let gameState = 'start'; // Start on the start screen
        let enemiesRemainingInWave = 0;
        let noEnemiesTimer = 0;

        // Movement and shooting
        let keys = {};
        let shooting = false;
        let firingBomb = false;
        let fireSoundPlaying = false;
        let mousePos = { x: canvas.width / 2, y: canvas.height / 2 };
        let screenShakeDuration = 0;

        // Enemy types
        const enemyTypes = [
            { name: 'Humie', image: images.humie, health: 30, speed: 3 * speedMultiplier, width: 34, height: 51, damage: 5, shootChance: 0.01, bulletSize: 20, projectile: images.humieProjectile },
            { name: 'Pointy-Ear', image: images.pointyEar, health: 20, speed: 6 * speedMultiplier, width: 26, height: 42.5, damage: 3, shootChance: 0.02, bulletSize: 16, projectile: images.pointyEarProjectile },
            { name: 'Tin-\'Ead', image: images.tinEad, health: 50, speed: 1.5 * speedMultiplier, width: 42.5, height: 59.5, damage: 10, shootChance: 0.005, bulletSize: 24, projectile: images.tinEadProjectile },
            { name: 'Space Nasty', image: images.spaceNasty, health: 40, speed: 4.5 * speedMultiplier, width: 51, height: 68, damage: 7, shootChance: 0.015, bulletSize: 28, projectile: images.spaceNastyProjectile }
        ];

        function drawOrkShip() {
            ctx.save();
            ctx.translate(orkShip.x + orkShip.width / 2, orkShip.y + orkShip.height / 2);
            ctx.rotate(orkShip.angle);
            ctx.translate(-orkShip.width / 2, -orkShip.height / 2);

            ctx.drawImage(orkShip.image, 0, 0, orkShip.width, orkShip.height);

            ctx.restore();
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                ctx.save();
                ctx.translate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                ctx.rotate(enemy.angle);
                ctx.translate(-enemy.width / 2, -enemy.height / 2);

                ctx.drawImage(enemy.image, 0, 0, enemy.width, enemy.height);

                ctx.restore();
            });
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.save();
                ctx.translate(bullet.x, bullet.y);
                ctx.rotate(bullet.angle);
                ctx.translate(-bullet.width / 2, -bullet.height / 2); // Center the bullet
                ctx.drawImage(bullet.image, 0, 0, bullet.width, bullet.height);
                ctx.restore();
            });
        }

        function drawEnemyBullets() {
            enemyBullets.forEach(bullet => {
                ctx.save();
                ctx.translate(bullet.x, bullet.y);
                ctx.rotate(bullet.angle);
                ctx.translate(-bullet.width / 2, -bullet.height / 2); // Center the bullet
                ctx.drawImage(bullet.image, 0, 0, bullet.width, bullet.height);
                ctx.restore();
            });
        }

        function drawParticles() {
            particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
            });
        }

        function drawExplosions() {
            explosions.forEach(explosion => {
                ctx.drawImage(explosion.image, 
                              explosion.frame * explosion.frameWidth, 0, explosion.frameWidth, explosion.frameHeight, 
                              explosion.x - (explosion.frameWidth), explosion.y - (explosion.frameHeight), 
                              explosion.frameWidth * 2, explosion.frameHeight * 2);
            });
        }

        function drawBombs() {
            bombs.forEach(bomb => {
                if (!bomb.exploded) {
                    ctx.drawImage(images.bomb, bomb.x - bomb.width / 2, bomb.y - bomb.height / 2, bomb.width, bomb.height);
                }
            });
        }

        function moveEnemies() {
            enemies.forEach(enemy => {
                const dx = orkShip.x - enemy.x;
                const dy = orkShip.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                let avoidDx = 0;
                let avoidDy = 0;

                // Calculate avoidance vector for each bullet
                bullets.forEach(bullet => {
                    const bulletDx = bullet.x - enemy.x;
                    const bulletDy = bullet.y - enemy.y;
                    const bulletDist = Math.sqrt(bulletDx * bulletDx + bulletDy * bulletDy);
                    if (bulletDist < 200) { // Increased detection radius
                        avoidDx -= bulletDx / bulletDist;
                        avoidDy -= bulletDy / bulletDist;
                    }
                });

                // Calculate avoidance vector for each enemy bullet, except their own
                enemyBullets.forEach(bullet => {
                    if (bullet.shooter !== enemy) { // Only avoid bullets not shot by themselves
                        const bulletDx = bullet.x - enemy.x;
                        const bulletDy = bullet.y - enemy.y;
                        const bulletDist = Math.sqrt(bulletDx * bulletDx + bulletDy * bulletDy);
                        if (bulletDist < 200) { // Increased detection radius
                            avoidDx -= bulletDx / bulletDist;
                            avoidDy -= bulletDy / bulletDist;
                        }
                    }
                });

                // Normalize avoidance vector
                const avoidDist = Math.sqrt(avoidDx * avoidDx + avoidDy * avoidDy);
                if (avoidDist > 0) {
                    avoidDx = (avoidDx / avoidDist) * enemy.speed * 1.5; // Increased avoidance maneuver
                    avoidDy = (avoidDy / avoidDist) * enemy.speed * 1.5; // Increased avoidance maneuver
                }

                // Combine movement towards player and avoidance
                enemy.vx = ((dx / dist) * enemy.speed + avoidDx) / 2;
                enemy.vy = ((dy / dist) * enemy.speed + avoidDy) / 2;
                enemy.x += enemy.vx;
                enemy.y += enemy.vy;
                enemy.angle = Math.atan2(enemy.vy, enemy.vx) + Math.PI / 2;

                // Remove enemy if it goes out of bounds
                if (enemy.y > canvas.height + enemy.height || enemy.y < -enemy.height || enemy.x > canvas.width + enemy.width || enemy.x < -enemy.width) {
                    enemies = enemies.filter(e => e !== enemy);
                    enemiesRemainingInWave--;
                }
            });
        }

        function moveBullets() {
            bullets.forEach(bullet => {
                bullet.x += 8.75 * speedMultiplier * Math.cos(bullet.angle); // Adjusted speed
                bullet.y += 8.75 * speedMultiplier * Math.sin(bullet.angle); // Adjusted speed
                if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                    bullets = bullets.filter(b => b !== bullet);
                }
            });
        }

        function moveEnemyBullets() {
            enemyBullets.forEach(bullet => {
                bullet.x += bullet.speed * 1.25 * speedMultiplier * Math.cos(bullet.angle); // Adjusted speed
                bullet.y += bullet.speed * 1.25 * speedMultiplier * Math.sin(bullet.angle); // Adjusted speed
                if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                    enemyBullets = enemyBullets.filter(b => b !== bullet);
                }
            });
        }

        function moveBombs() {
            bombs.forEach((bomb, index) => {
                bomb.x += bomb.speed * speedMultiplier * Math.cos(bomb.angle);
                bomb.y += bomb.speed * speedMultiplier * Math.sin(bomb.angle);

                // Calculate the distance bomb has traveled
                const dx = bomb.x - bomb.initialX;
                const dy = bomb.y - bomb.initialY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Check if bomb has traveled beyond a certain distance before exploding
                if (dist > bomb.maxTravelDistance) {
                    bomb.exploded = true;
                    const increasedRadius = bomb.radius * 1.3; // Increase radius by 30%
                    createExplosion(bomb.x, bomb.y, images.shipExplosion, 64, 64, 16, 'ship', increasedRadius);
                    bombSound.play();
                    setTimeout(() => {
                        bombs.splice(index, 1);
                    }, 1000); // Extend the time before it explodes by 1 second
                    bomb.exploding = true;
                }
            });
        }

        function moveParticles() {
            particles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                if (particle.life <= 0) {
                    particles = particles.filter(p => p !== particle);
                }
            });
        }

        function moveExplosions() {
            explosions.forEach((explosion, index) => {
                explosion.frame++;
                if (explosion.frame >= explosion.totalFrames * 2) { // Explosions last twice as long
                    explosions.splice(index, 1);
                }
            });
        }

        function spawnEnemy() {
            if (enemiesRemainingInWave > 0 && Math.random() < 0.02) {
                const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                const spawnEdge = Math.floor(Math.random() * 4); // Randomly choose an edge: 0=top, 1=right, 2=bottom, 3=left
                let x, y;

                switch (spawnEdge) {
                    case 0: // top
                        x = Math.random() * canvas.width;
                        y = -type.height;
                        break;
                    case 1: // right
                        x = canvas.width + type.width;
                        y = Math.random() * canvas.height;
                        break;
                    case 2: // bottom
                        x = Math.random() * canvas.width;
                        y = canvas.height + type.height;
                        break;
                    case 3: // left
                        x = -type.width;
                        y = Math.random() * canvas.height;
                        break;
                }

                enemies.push({
                    ...type,
                    x: x,
                    y: y,
                    angle: 0,
                    vx: 0,
                    vy: 0
                });
                enemiesRemainingInWave--;
            }
        }

        function enemyShoot() {
            enemies.forEach(enemy => {
                if (Math.random() < enemy.shootChance) {
                    const dx = orkShip.x - enemy.x;
                    const dy = orkShip.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    enemyBullets.push({
                        x: enemy.x + enemy.width / 2,
                        y: enemy.y + enemy.height / 2,
                        width: enemy.bulletSize,  // Adjust as necessary for projectile size
                        height: enemy.bulletSize,  // Adjust as necessary for projectile size
                        image: enemy.projectile,
                        speed: 5 * speedMultiplier,  // Adjusted speed
                        angle: angle,
                        shooter: enemy // Track the shooter
                    });
                }
            });
        }

        function checkCollisions() {
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    if (bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + enemy.height > enemy.y) {
                        enemy.health -= 10 + orkShip.shootas * 2;
                        bullets = bullets.filter(b => b !== bullet);
                        createParticles(enemy.x, enemy.y, enemy.color);
                        createExplosion(enemy.x, enemy.y, images.shipExplosion, 64, 64, 16, 'ship');
                        if (enemy.health <= 0) {
                            enemies = enemies.filter(e => e !== enemy);
                            score += 10;
                            orkShip.scrap += 2;
                            waaghMeter += 5;
                            orkShip.ammo += 10; // Give ammo for each enemy destroyed
                            screenShake(10); // Screen shake effect
                            updateHUD(); // Update scrap count in real-time
                        }
                    }
                });
            });

            enemyBullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    if (enemy !== bullet.shooter && // Ensure the bullet doesn't immediately damage the shooter
                        bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y) {
                        enemy.health -= 10; // Adjust damage as necessary
                        enemyBullets = enemyBullets.filter(b => b !== bullet);
                        createParticles(enemy.x, enemy.y, enemy.color);
                        createExplosion(enemy.x, enemy.y, images.shipExplosion, 64, 64, 16, 'ship');
                        if (enemy.health <= 0) {
                            enemies = enemies.filter(e => e !== enemy);
                            score += 10;
                            orkShip.scrap += 2;
                            waaghMeter += 5;
                            orkShip.ammo += 10; // Give ammo for each enemy destroyed
                            screenShake(10); // Screen shake effect
                        }
                    }
                });

                if (bullet.x < orkShip.x + orkShip.width &&
                    bullet.x + bullet.width > orkShip.x &&
                    bullet.y < orkShip.y + orkShip.height &&
                    bullet.y + bullet.height > orkShip.y) {
                    orkShip.health -= Math.max(bullet.width - orkShip.arma, 1); // Minimum damage of 1
                    enemyBullets = enemyBullets.filter(b => b !== bullet);
                    createParticles(orkShip.x, orkShip.y, 'red');
                    createExplosion(orkShip.x, orkShip.y, images.shipExplosion, 64, 64, 16, 'ship');
                    if (orkShip.health <= 0) {
                        gameState = 'gameOver';
                        document.getElementById('gameOverMenu').style.display = 'block';
                    }
                }
            });

            bullets.forEach((bullet, bulletIndex) => {
                enemyBullets.forEach((enemyBullet, enemyBulletIndex) => {
                    if (bullet.x < enemyBullet.x + enemyBullet.width &&
                        bullet.x + bullet.width > enemyBullet.x &&
                        bullet.y < enemyBullet.y + enemyBullet.height &&
                        bullet.y + bullet.height > enemyBullet.y) {
                        bullets.splice(bulletIndex, 1);
                        enemyBullets.splice(enemyBulletIndex, 1);
                        createParticles((bullet.x + enemyBullet.x) / 2, (bullet.y + enemyBullet.y) / 2, 'orange');
                        createExplosion((bullet.x + enemyBullet.x) / 2, (bullet.y + enemyBullet.y) / 2, images.projectileExplosion, 32, 32, 16, 'projectile');
                    }
                });
            });

            enemies.forEach(enemy => {
                if (enemy.x < orkShip.x + orkShip.width &&
                    enemy.x + enemy.width > orkShip.x &&
                    enemy.y < orkShip.y + orkShip.height &&
                    enemy.y + enemy.height > orkShip.y) {
                    orkShip.health -= Math.max(enemy.damage - orkShip.arma, 1); // Minimum damage of 1
                    orkShip.ammo += 10; // Refill ammo on collision
                    enemies = enemies.filter(e => e !== enemy);
                    createParticles(orkShip.x, orkShip.y, 'red');
                    createExplosion(orkShip.x, orkShip.y, images.shipExplosion, 64, 64, 16, 'ship');
                    if (orkShip.health <= 0) {
                        gameState = 'gameOver';
                        document.getElementById('gameOverMenu').style.display = 'block';
                    }
                }
            });

            bombs.forEach((bomb, index) => {
                if (bomb.exploded) {
                    enemies.forEach(enemy => {
                        const dx = bomb.x - enemy.x;
                        const dy = bomb.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < bomb.radius) {
                            enemy.health = 0; // Instant kill
                            createParticles(enemy.x, enemy.y, enemy.color);
                            createExplosion(enemy.x, enemy.y, images.shipExplosion, 64, 64, 16, 'ship');
                            enemies = enemies.filter(e => e !== enemy);
                            score += 10;
                            orkShip.scrap += 2;
                            waaghMeter += 5;
                            orkShip.ammo += 10; // Give ammo for each enemy destroyed
                            screenShake(10); // Screen shake effect
                        }
                    });

                    // Check for projectiles within bomb radius
                    bullets.forEach((bullet, bulletIndex) => {
                        const dx = bomb.x - bullet.x;
                        const dy = bomb.y - bullet.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < bomb.radius) {
                            bullets.splice(bulletIndex, 1);
                            createParticles(bullet.x, bullet.y, 'orange');
                            createExplosion(bullet.x, bullet.y, images.projectileExplosion, 32, 32, 16, 'projectile');
                        }
                    });

                    enemyBullets.forEach((bullet, bulletIndex) => {
                        const dx = bomb.x - bullet.x;
                        const dy = bomb.y - bullet.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < bomb.radius) {
                            enemyBullets.splice(bulletIndex, 1);
                            createParticles(bullet.x, bullet.y, 'orange');
                            createExplosion(bullet.x, bullet.y, images.projectileExplosion, 32, 32, 16, 'projectile');
                        }
                    });

                    // Remove bomb from array after checking for collisions
                    bombs.splice(index, 1);
                }
            });

            // Check for level completion
            if (enemiesRemainingInWave === 0 && enemies.length === 0) {
                gameState = 'upgrading';
                showUpgradeMenu();
            }
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x,
                    y: y,
                    size: Math.random() * 5 + 2,
                    color: color,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: Math.random() * 20 + 10
                });
            }
        }

        function createExplosion(x, y, image, frameWidth, frameHeight, totalFrames, type, radius = 0) {
            explosions.push({ x: x, y: y, image: image, frame: 0, frameWidth: frameWidth, frameHeight: frameHeight, totalFrames: totalFrames, radius: radius });
            const sound = new Audio(type === 'ship' ? 'https://cdn.freesound.org/previews/609/609587_1038806-lq.mp3' : 'https://cdn.freesound.org/previews/609/609588_1038806-lq.mp3');
            sound.play();
        }

        function drawHUD() {
            ctx.fillStyle = '#0f0';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${score}  Scrap: ${orkShip.scrap}  Health: ${orkShip.health}`, 10, 30);
            ctx.fillText(`WAAAGH!: ${waaghMeter}%  Level: ${level}  Wave: ${wave}`, 10, 60);
            ctx.drawImage(images.orkProjectile, canvas.width - 100, canvas.height - 60, 50, 50); // Draw ammo image
            ctx.fillText(`${orkShip.ammo}`, canvas.width - 50, canvas.height - 30); // Ammo counter
            ctx.fillText(`Guzzle: ${Math.floor(orkShip.guzzle)}`, 10, 90); // Display Guzzle meter
            document.getElementById('currentScrap').innerText = `Scrap: ${orkShip.scrap}`; // Update scrap in upgrade menu
        }

        function drawBackground() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Add some stars
            for (let i = 0; i < 100; i++) {
                ctx.fillStyle = 'white';
                ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 1, 1);
            }
        }

        function updateMovement() {
            if (keys['Shift'] && orkShip.guzzle > 0) {
                orkShip.isBoosting = true;
                orkShip.speed = orkShip.originalSpeed * 2.2 * speedMultiplier; // Adjusted speed
                orkShip.guzzle -= 0.5; // Decrease Guzzle meter
                if (orkShip.guzzle < 0) {
                    orkShip.guzzle = 0;
                }
            } else {
                orkShip.isBoosting = false;
                orkShip.speed = orkShip.originalSpeed * speedMultiplier; // Adjusted speed
            }

            if (keys['ArrowUp'] || keys['w']) {
                orkShip.y = Math.max(0, orkShip.y - orkShip.speed);
            }
            if (keys['ArrowDown'] || keys['s']) {
                orkShip.y = Math.min(canvas.height - orkShip.height, orkShip.y + orkShip.speed);
            }
            if (keys['ArrowLeft'] || keys['a']) {
                orkShip.x = Math.max(0, orkShip.x - orkShip.speed);
            }
            if (keys['ArrowRight'] || keys['d']) {
                orkShip.x = Math.min(canvas.width - orkShip.width, orkShip.x + orkShip.speed);
            }
        }

        function updateShooting() {
            if (shooting && (orkShip.ammo > 0 || orkShip.waaaghActive)) {
                const angle = calculateAngle(orkShip.x + orkShip.width / 2, orkShip.y + orkShip.height / 2, mousePos.x, mousePos.y);
                for (let i = 0; i < orkShip.shootas; i++) {
                    bullets.push({
                        x: orkShip.x + orkShip.width / 2,
                        y: orkShip.y + orkShip.height / 2,
                        width: 40,  // Adjusted to double size
                        height: 40,  // Adjusted to double size
                        image: images.orkProjectile,
                        angle: angle // Shoot towards the mouse
                    });
                }
                if (!orkShip.waaaghActive) {
                    orkShip.ammo--;
                }
                if (!fireSoundPlaying) {
                    fireSound.play();
                    fireSoundPlaying = true;
                }
            } else {
                if (fireSoundPlaying) {
                    fireSound.pause();
                    fireSound.currentTime = 0; // Reset to start
                    fireSoundPlaying = false;
                }
            }

            if (firingBomb && orkShip.ammo >= 70) {
                const angle = calculateAngle(orkShip.x + orkShip.width / 2, orkShip.y + orkShip.height / 2, mousePos.x, mousePos.y);
                bombs.push({
                    x: orkShip.x + orkShip.width / 2,
                    y: orkShip.y,
                    initialX: orkShip.x + orkShip.width / 2, // Initial position
                    initialY: orkShip.y, // Initial position
                    width: 50,
                    height: 50,
                    speed: 5 * speedMultiplier, // Adjusted speed
                    angle: angle, // Direction towards the mouse
                    radius: canvas.width / 10, // Halved explosion radius
                    maxTravelDistance: 300, // Set the max travel distance before detonation
                    exploded: false,
                    exploding: false
                });
                orkShip.ammo -= 70;
                firingBomb = false; // Set firingBomb to false after firing a bomb
            }
        }

        function screenShake(duration) {
            screenShakeDuration = duration;
        }

        function applyScreenShake() {
            if (screenShakeDuration > 0) {
                const shakeMagnitude = 5;
                const shakeX = (Math.random() - 0.5) * shakeMagnitude;
                const shakeY = (Math.random() - 0.5) * shakeMagnitude;
                ctx.translate(shakeX, shakeY);
                screenShakeDuration--;
            }
        }

        function gameLoop() {
            ctx.save();  // Save the current state before applying screen shake
            applyScreenShake();

            if (gameState === 'playing') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
                drawOrkShip();
                drawEnemies();
                drawBullets();
                drawEnemyBullets();
                drawParticles();
                drawExplosions();
                drawBombs();
                drawHUD();
                
                updateMovement();
                updateShooting();
                moveEnemies();
                moveBullets();
                moveEnemyBullets();
                moveBombs();
                moveParticles();
                moveExplosions();
                spawnEnemy();
                enemyShoot();
                checkCollisions();

                // Check if there are no enemies on screen
                if (enemies.length === 0) {
                    noEnemiesTimer++;
                    if (noEnemiesTimer >= 360) { // 6 seconds at 60 FPS
                        gameState = 'upgrading';
                        showUpgradeMenu();
                        noEnemiesTimer = 0; // Reset the timer
                    }
                } else {
                    noEnemiesTimer = 0; // Reset the timer if enemies are present
                }

                if (waaghMeter >= 100) {
                    activateWaaagh();
                }
            } else if (gameState === 'gameOver') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
                document.getElementById('gameOverMenu').style.display = 'block';
            }

            ctx.restore();  // Restore the state after applying screen shake
            
            requestAnimationFrame(gameLoop);
        }

        function activateWaaagh() {
            orkShip.waaaghActive = true;
            orkShip.image = images.waaaghShip;
            orkShip.color = 'red';
            orkShip.speed = orkShip.originalSpeed * 2 * speedMultiplier; // Adjusted speed
            waaaghSound.play(); // Play Waaagh activation sound
            orkShip.waaaghAmmoGranted = false; // Reset the flag
            
            setTimeout(() => {
                deactivateWaaagh();
            }, 5000); // Ensure Waaagh is deactivated after 5 seconds
        }

        function deactivateWaaagh() {
            orkShip.image = images.orkShip;
            orkShip.color = 'green';
            orkShip.speed = orkShip.originalSpeed * speedMultiplier; // Adjusted speed
            orkShip.waaaghActive = false;

            // Check if ammo has already been granted for this Waaagh cycle
            if (!orkShip.waaaghAmmoGranted) {
                orkShip.ammo += 100; // Increase ammo by 100 after Waaagh
                orkShip.waaaghAmmoGranted = true; // Set the flag to true
            }

            waaghMeter = 0;
        }

        function showUpgradeMenu() {
            updateHUD();
            document.getElementById('upgradeMenu').style.display = 'block';
        }

        function upgradeShootas() {
            if (orkShip.scrap >= 10) {
                orkShip.shootas++;
                orkShip.scrap -= 10;
                updateHUD();
            }
        }

        function upgradeArma() {
            if (orkShip.scrap >= 15) {
                orkShip.arma++;
                orkShip.scrap -= 15;
                updateHUD();
            }
        }

        function upgradeSpeed() {
            if (orkShip.scrap >= 5) {
                orkShip.originalSpeed++; // Increment originalSpeed instead of speed
                orkShip.scrap -= 5;
                updateHUD();
            }
        }

        function updateHUD() {
            // Update the display of the current scrap amount
            document.getElementById('currentScrap').innerText = `Scrap: ${orkShip.scrap}`;
            // Update HUD
            ctx.fillStyle = '#0f0';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${score}  Scrap: ${orkShip.scrap}  Health: ${orkShip.health}`, 10, 30);
            ctx.fillText(`WAAAGH!: ${waaghMeter}%  Level: ${level}  Wave: ${wave}`, 10, 60);
            ctx.drawImage(images.orkProjectile, canvas.width - 100, canvas.height - 60, 50, 50); // Draw ammo image
            ctx.fillText(`${orkShip.ammo}`, canvas.width - 50, canvas.height - 30); // Ammo counter
            ctx.fillText(`Guzzle: ${Math.floor(orkShip.guzzle)}`, 10, 90); // Display Guzzle meter
        }

        function startNextWave() {
            document.getElementById('upgradeMenu').style.display = 'none';
            gameState = 'playing';
            enemiesRemainingInWave = wave * 5; // Increase the number of enemies per wave
            wave++;
            orkShip.guzzle = 100; // Reset Guzzle meter
            orkShip.health = 100; // Reset health
            updateHUD();
        }

        function restartGame() {
            document.getElementById('gameOverMenu').style.display = 'none';
            // Reset game state
            orkShip.x = canvas.width / 2;
            orkShip.y = canvas.height - 100;
            orkShip.width = 60;  // Doubled the width
            orkShip.height = 80; // Doubled the height
            orkShip.image = images.orkShip; // Reset to original image
            orkShip.color = 'green';
            orkShip.speed = orkShip.originalSpeed * speedMultiplier; // Adjusted speed
            orkShip.shootas = 1;
            orkShip.arma = 0;
            orkShip.scrap = 0;
            orkShip.health = 100;
            orkShip.ammo = 100;
            orkShip.waaaghActive = false;
            orkShip.waaaghSpeedBoost = 2;
            orkShip.originalSpeed = 5;
            orkShip.waaaghAmmoBoost = false;
            orkShip.waaaghAmmoGranted = false; // Reset flag
            orkShip.guzzle = 100; // Reset Guzzle meter
            enemies = [];
            bullets = [];
            enemyBullets = [];
            bombs = [];
            particles = [];
            explosions = [];
            score = 0;
            level = 1;
            wave = 1;
            waaghMeter = 0;
            enemiesRemainingInWave = wave * 5; // Initial number of enemies
            gameState = 'playing';

            // Initialize the scrap display
            updateHUD();

            gameLoop(); // Start the game loop
        }

        // Calculate angle to rotate the ship towards the mouse
        function calculateAngle(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        }

        document.addEventListener('mousemove', (event) => {
            mousePos.x = event.clientX;
            mousePos.y = event.clientY;
            orkShip.angle = calculateAngle(orkShip.x + orkShip.width / 2, orkShip.y + orkShip.height / 2, mousePos.x, mousePos.y) + Math.PI;
        });

        document.addEventListener('mousedown', (event) => {
            if (event.button === 0 && gameState === 'playing') { // Left mouse button
                shooting = true;
            } else if (event.button === 2 && gameState === 'playing') { // Right mouse button
                firingBomb = true;
            }
        });

        document.addEventListener('mouseup', (event) => {
            if (event.button === 0) { // Left mouse button
                shooting = false;
            }
        });

        document.addEventListener('keydown', (event) => {
            keys[event.key] = true;
        });

        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        document.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });

        // Touch event listeners
        document.addEventListener('touchstart', handleTouchStart, false);
        document.addEventListener('touchmove', handleTouchMove, false);
        document.addEventListener('touchend', handleTouchEnd, false);

        let touchStartX = null;
        let touchStartY = null;

        function handleTouchStart(event) {
            const touch = event.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;

            // Detect touch areas for movement
            if (touchStartX < window.innerWidth / 2) {
                // Left side for movement
                keys['ArrowUp'] = true;
            } else {
                // Right side for shooting
                shooting = true;
            }
        }

        function handleTouchMove(event) {
            if (!touchStartX || !touchStartY) return;

            const touch = event.touches[0];
            const touchMoveX = touch.clientX;
            const touchMoveY = touch.clientY;

            const dx = touchMoveX - touchStartX;
            const dy = touchMoveY - touchStartY;

            if (dx > 50) {
                // Right swipe
                keys['ArrowRight'] = true;
                keys['ArrowLeft'] = false;
            } else if (dx < -50) {
                // Left swipe
                keys['ArrowLeft'] = true;
                keys['ArrowRight'] = false;
            }

            if (dy > 50) {
                // Down swipe
                keys['ArrowDown'] = true;
                keys['ArrowUp'] = false;
            } else if (dy < -50) {
                // Up swipe
                keys['ArrowUp'] = true;
                keys['ArrowDown'] = false;
            }
        }

        function handleTouchEnd(event) {
            // Reset movement keys on touch end
            keys['ArrowUp'] = false;
            keys['ArrowDown'] = false;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
            shooting = false;
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameState = 'playing';
            restartGame();
        }

        // Show start screen on load
        document.getElementById('startScreen').style.display = 'block';
    </script>
</body>
</html>
